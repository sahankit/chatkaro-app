// Copy this entire content for index.js in Glitch

const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const cors = require('cors');
const { v4: uuidv4 } = require('uuid');

console.log('ðŸš€ Starting ChatKaro Server...');

const app = express();
const server = http.createServer(app);

// Configure Socket.IO with CORS
const io = socketIo(server, {
  cors: {
    origin: "*",
    methods: ["GET", "POST"],
    credentials: true
  },
  transports: ['websocket', 'polling']
});

// Basic middleware
app.use(cors());
app.use(express.json());

// Simple in-memory storage
const users = new Map();
const usernames = new Set();
const rooms = new Map();

// Initialize default rooms
const defaultRooms = [
  { id: 'general', name: 'General Chat', description: 'General discussion' },
  { id: 'tech', name: 'Tech Talk', description: 'Technology discussions' },
  { id: 'gaming', name: 'Gaming', description: 'Gaming discussions' },
  { id: 'music', name: 'Music', description: 'Music and entertainment' },
  { id: 'sports', name: 'Sports', description: 'Sports discussions' },
  { id: 'food', name: 'Food & Cooking', description: 'Food and cooking' },
  { id: 'movies', name: 'Movies & TV', description: 'Movies and TV shows' },
  { id: 'books', name: 'Books', description: 'Book discussions' },
  { id: 'travel', name: 'Travel', description: 'Travel experiences' },
  { id: 'fitness', name: 'Fitness', description: 'Health and fitness' },
  { id: 'art', name: 'Art & Design', description: 'Art and design' },
  { id: 'science', name: 'Science', description: 'Science discussions' },
  { id: 'business', name: 'Business', description: 'Business and entrepreneurship' },
  { id: 'education', name: 'Education', description: 'Learning and education' },
  { id: 'random', name: 'Random', description: 'Random conversations' },
  { id: 'help', name: 'Help & Support', description: 'Get help and support' }
];

defaultRooms.forEach(roomData => {
  rooms.set(roomData.id, {
    id: roomData.id,
    name: roomData.name,
    description: roomData.description,
    users: new Set(),
    messages: []
  });
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    users: users.size,
    rooms: rooms.size
  });
});

// Socket.IO connection handling
io.on('connection', (socket) => {
  console.log(`ðŸ‘¤ New connection: ${socket.id}`);

  // Send rooms list to newly connected client
  const roomsList = Array.from(rooms.values()).map(room => ({
    id: room.id,
    name: room.name,
    description: room.description,
    userCount: room.users.size
  }));
  socket.emit('rooms_list', roomsList);

  // Handle user joining
  socket.on('join', (userData) => {
    const { username } = userData;
    
    if (!username || username.trim().length === 0) {
      socket.emit('join_error', { message: 'Username is required' });
      return;
    }

    const trimmedUsername = username.trim();
    
    if (usernames.has(trimmedUsername.toLowerCase())) {
      socket.emit('join_error', { message: 'Username already taken' });
      return;
    }

    // Create user
    const user = {
      id: socket.id,
      username: trimmedUsername,
      joinedAt: new Date().toISOString(),
      currentRoom: null
    };

    users.set(socket.id, user);
    usernames.add(trimmedUsername.toLowerCase());

    socket.emit('user_joined', { user });
    console.log(`âœ… ${user.username} joined (${socket.id})`);
  });

  // Handle room joining
  socket.on('join_room', (roomData) => {
    const user = users.get(socket.id);
    if (!user) return;

    const { roomId } = roomData;
    const room = rooms.get(roomId);
    if (!room) return;

    // Leave previous room
    if (user.currentRoom) {
      const prevRoom = rooms.get(user.currentRoom);
      if (prevRoom) {
        prevRoom.users.delete(socket.id);
        socket.leave(user.currentRoom);
        
        // Notify users in previous room
        const prevRoomUsers = Array.from(prevRoom.users).map(userId => users.get(userId)?.username).filter(Boolean);
        socket.to(user.currentRoom).emit('user_left', {
          username: user.username,
          userCount: prevRoom.users.size,
          updatedUsers: prevRoomUsers
        });

        // Update room count for previous room
        io.emit('room_updated', {
          roomId: user.currentRoom,
          userCount: prevRoom.users.size
        });
      }
    }

    // Join new room
    room.users.add(socket.id);
    socket.join(roomId);
    user.currentRoom = roomId;

    const roomUsers = Array.from(room.users).map(userId => users.get(userId)?.username).filter(Boolean);

    const currentRoomData = {
      roomId: roomId,
      roomName: room.name,
      messages: room.messages.slice(-50), // Last 50 messages
      users: roomUsers
    };

    socket.emit('room_joined', currentRoomData);

    // Notify other users in the room
    socket.to(roomId).emit('user_joined_room', {
      username: user.username,
      userCount: room.users.size,
      updatedUsers: roomUsers
    });

    // Update room count
    io.emit('room_updated', {
      roomId: roomId,
      userCount: room.users.size
    });

    // Send updated rooms list
    const updatedRoomsList = Array.from(rooms.values()).map(room => ({
      id: room.id,
      name: room.name,
      description: room.description,
      userCount: room.users.size
    }));
    io.emit('rooms_list', updatedRoomsList);

    console.log(`ðŸ  ${user.username} joined room: ${room.name}`);
  });

  // Handle messages
  socket.on('send_message', (messageData) => {
    const user = users.get(socket.id);
    if (!user || !user.currentRoom) return;

    const room = rooms.get(user.currentRoom);
    if (!room) return;

    const message = {
      id: uuidv4(),
      username: user.username,
      content: messageData.content,
      timestamp: new Date().toISOString(),
      roomId: user.currentRoom
    };

    room.messages.push(message);
    
    // Keep only last 100 messages
    if (room.messages.length > 100) {
      room.messages = room.messages.slice(-100);
    }

    io.to(user.currentRoom).emit('new_message', message);
    console.log(`ðŸ’¬ ${user.username} in ${room.name}: ${message.content}`);
  });

  // Handle session restoration
  socket.on('restore_session', (sessionData) => {
    const { username, room } = sessionData;

    if (!username || username.trim().length === 0) {
      socket.emit('session_restore_failed', { message: 'Invalid username in session' });
      return;
    }

    const trimmedUsername = username.trim();

    // Check if username is available
    if (usernames.has(trimmedUsername.toLowerCase())) {
      socket.emit('session_restore_failed', { message: 'Username already taken' });
      return;
    }

    // Create user
    const user = {
      id: socket.id,
      username: trimmedUsername,
      joinedAt: new Date().toISOString(),
      currentRoom: null
    };

    users.set(socket.id, user);
    usernames.add(trimmedUsername.toLowerCase());

    console.log(`ðŸ”„ Session restored: ${user.username} (${socket.id})`);

    // If there's a room in the session, try to join it
    if (room && rooms.has(room)) {
      const roomData = rooms.get(room);
      roomData.users.add(socket.id);
      socket.join(room);
      user.currentRoom = room;

      const roomUsers = Array.from(roomData.users).map(userId => users.get(userId)?.username).filter(Boolean);

      const currentRoomData = {
        roomId: room,
        roomName: roomData.name,
        messages: roomData.messages.slice(-50),
        users: roomUsers
      };

      socket.emit('session_restored', {
        user: user,
        currentRoom: currentRoomData
      });

      // Notify other users in the room
      socket.to(room).emit('user_joined_room', {
        username: user.username,
        userCount: roomData.users.size,
        updatedUsers: roomUsers
      });

      // Update room count
      io.emit('room_updated', {
        roomId: room,
        userCount: roomData.users.size
      });

      // Send updated rooms list
      const updatedRoomsList = Array.from(rooms.values()).map(room => ({
        id: room.id,
        name: room.name,
        description: room.description,
        userCount: room.users.size
      }));
      io.emit('rooms_list', updatedRoomsList);

      console.log(`ðŸ”„ ${user.username} restored to room: ${roomData.name}`);
    } else {
      // Just restore user without room
      socket.emit('session_restored', {
        user: user,
        currentRoom: null
      });
    }
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    const user = users.get(socket.id);
    if (user) {
      // Remove from current room
      if (user.currentRoom) {
        const room = rooms.get(user.currentRoom);
        if (room) {
          room.users.delete(socket.id);
          
          const roomUsers = Array.from(room.users).map(userId => users.get(userId)?.username).filter(Boolean);
          
          socket.to(user.currentRoom).emit('user_left', {
            username: user.username,
            userCount: room.users.size,
            updatedUsers: roomUsers
          });

          // Update room count
          io.emit('room_updated', {
            roomId: user.currentRoom,
            userCount: room.users.size
          });

          // Send updated rooms list
          const updatedRoomsList = Array.from(rooms.values()).map(room => ({
            id: room.id,
            name: room.name,
            description: room.description,
            userCount: room.users.size
          }));
          io.emit('rooms_list', updatedRoomsList);
        }
      }

      // Clean up user data
      usernames.delete(user.username.toLowerCase());
      users.delete(socket.id);
      console.log(`ðŸ‘‹ ${user.username} disconnected (${socket.id})`);
    }
  });
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`ðŸŽ‰ ChatKaro server running on port ${PORT}`);
  console.log(`ðŸ“Š Health check: http://localhost:${PORT}/health`);
});
